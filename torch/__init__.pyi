
from typing import (Any, List, Iterator, Union, Tuple, BinaryIO,
                    overload, Sequence, Optional, TypeVar, ContextManager)


class Tensor:
    data = ...  # type: Any
    def __init__(self, _arr : Any) -> None : ...
    def __getitem__(self, indices : Union[int, slice, Tuple[Union[slice, int], ...]]) \
        -> Any: ...

    def __add__(self, other : Union[float, 'Tensor']) -> 'Tensor' : ...
    def add(self, _other: float) -> 'Tensor' : ...
    def __radd__(self, other : float) -> 'Tensor' : ...
    def __mul__(self, other : Union[float, 'Tensor']) -> 'Tensor' : ...
    def __rmul__(self, other : float) -> 'Tensor' : ...
    def __truediv__(self, other : float) -> 'Tensor' : ...
    def __iter__(self) -> Iterator[Any] : ...
    def __next__(self) -> Any: ...
    def expand_as(self, _t : 'Tensor') -> 'Tensor' : ...
    def expand(self, *_sizes : int) -> 'Tensor' : ...
    def squeeze(self, _dim : Optional[int]=None) -> 'Tensor' : ...
    def unsqueeze(self, _dim : int) -> 'Tensor' : ...
    def topk(self, _k : int) -> Tuple['Tensor', 'LongTensor'] : ...
    def sort(self, _dim : Optional[int] = None, _descending : bool = False) : ...
    def index_select(self, _dim : int, _index : 'LongTensor') -> 'Tensor' : ...
    def fill_(self, _value : float) -> None : ...
    def index_fill_(self, _dim : int, _index : 'LongTensor' , _value : float) \
        -> None : ...

    def cuda(self) -> 'Tensor': ...
    def view(self, *_sizes : Union['Tensor', int]) -> 'Tensor' : ...
    def size(self, _dim : Optional[int] = None) -> 'Tensor' : ...
    def __len__(self) -> int : ...
    def backward(self) -> None : ...
    def repeat(self, *_sizes : int) -> 'Tensor' : ...
    def item(self) -> Any: ...
    def contiguous(self) -> 'Tensor' : ...


T = TypeVar('T', bound=Tensor)


class ByteTensor(Tensor):
    def any(self) -> bool: ...
    def view(self, *_sizes: Union[Tensor, int]) -> 'ByteTensor': ...
    def expand(self, *_sizes: int) -> 'ByteTensor': ...


class BoolTensor(Tensor):
    def any(self) -> bool: ...
    def view(self, *_sizes: Union[Tensor, int]) -> 'BoolTensor': ...
    def expand(self, *_sizes: int) -> 'BoolTensor': ...


class LongTensor(Tensor):
    # @overload
    # def __add__(self, other : Union[float, 'Tensor']) -> 'Tensor' : ...
    # @overload
    # def __add__(self, other : Union[int, 'LongTensor']) -> 'LongTensor' : ...
    # @overload
    def add(self, _other: float) -> 'LongTensor' : ...
    def __mod__(self, other : Union[int, 'LongTensor']) -> 'LongTensor' : ...
    def __rmod__(self, other : int) -> 'LongTensor' : ...
    def squeeze(self, _dim : Optional[int]=None) -> 'LongTensor': ...
    def unsqueeze(self, _dim : int) -> 'LongTensor' : ...
    def expand_as(self, _t : 'Tensor') -> 'LongTensor' : ...
    def expand(self, *_sizes : int) -> 'LongTensor' : ...
    def view(self, *_sizes : Union[Tensor, int]) -> 'LongTensor' : ...
    def repeat(self, *_sizes : int) -> 'LongTensor' : ...
    def item(self) -> int: ...
    def contiguous(self) -> 'LongTensor' : ...
    def index_select(self, _dim: int, _index: 'LongTensor') -> 'LongTensor': ...
    def float(self) -> 'FloatTensor' : ...

class FloatTensor(Tensor):
    def __init__(self, *args : Any) -> None : ...
    def add(self, _other: float) -> 'FloatTensor' : ...
    def view(self, *_sizes : Union[Tensor, int]) -> 'FloatTensor' : ...
    def topk(self, _k : int) -> Tuple['FloatTensor', 'LongTensor'] : ...
    def repeat(self, *_sizes : int) -> 'FloatTensor' : ...
    def unsqueeze(self, _dim : int) -> 'FloatTensor' : ...
    def expand_as(self, _t : 'Tensor') -> 'FloatTensor' : ...
    def expand(self, *_sizes : int) -> 'FloatTensor' : ...
    def index_select(self, _dim : int, _index : 'LongTensor') -> 'FloatTensor' : ...
    def item(self) -> float: ...
    def contiguous(self) -> 'FloatTensor' : ...


float32: int
float64: int
long: int
def zeros(*_sizes : int, _dtype : Optional[int] = None, **kwargs) -> Tensor : ...
def zeros_like(_t : Tensor, _dtype : Optional[int] = None) -> Tensor : ...
@overload
def save(data : Any, filehandle: BinaryIO, ) -> None : ...
@overload
def save(data : Any, filepath: str) -> None : ...
@overload
def load(f_handle : BinaryIO, map_location:Optional[str]=None) -> Any : ...
@overload
def load(filename : str, map_location:Optional[str]=None) -> Any : ...
def transpose(_input : Tensor, _dim0 : int, _dim1 : int) -> Any : ...


def cat(_tensors: Sequence[T], _dim: int = 0) -> T: ...


def isnan(_tensor: Tensor) -> ByteTensor: ...


def isinf(_tensor: Tensor) -> ByteTensor: ...


def sum(_tensor: Tensor) -> Tensor: ...


def manual_seed(_n: int) -> None: ...


def where(_mask: ByteTensor, _t1: T, _t2: T) -> T: ...


def stack(_tensors: List[T]) -> T: ...
def full_like(_tensor: T, _value: Union[bool, int, float]) -> T: ...


def no_grad() -> ContextManager[Any]: ...


def div(_a: Tensor, _b: Tensor, _rounding_mode: str): ...


class Size:
    def __init__(self, _args: List[int]) -> None: ...
